%
% Automatic test code.
%
% NOTE: Very low code coverage.
%
function proc_sub23___ATEST()
    downsample_bin_sci_values___ATEST()
    downsample_Epoch___ATEST
end



function downsample_bin_sci_values___ATEST()
    newTest    = @(zVarSegment, nMinReqSamples, med, mstd) (...
        EJ_library.atest.CompareFuncResult(...
        @bicas.proc_sub23.downsample_bin_sci_values, ...
        {zVarSegment, nMinReqSamples}, ...
        {med, mstd}));
    
%     newTestExc = @(zVarSegment, nMinReqSamples) (...
%         EJ_library.atest.CompareFuncResult(...
%         @bicas.proc_sub23.downsample_bin_sci_values, ...
%         {zVarSegment}, ...
%         {med, mstd}));

    ERA = zeros(1,0);
    
    tl = {};
    
    % Empty data
    tl{end+1} = newTest(zeros(0,0), 0, ERA, ERA);
    tl{end+1} = newTest(zeros(0,2), 0, [NaN NaN], [NaN, NaN]);
    
    % mstd=0
    tl{end+1} = newTest([1,2,3              ], 0, [1,2,3], [nan,nan,nan]);
    tl{end+1} = newTest([1,2,3; 1,2,3       ], 0, [1,2,3], [0,0,0]);
    tl{end+1} = newTest([1,2,3; 1,2,3; 1,2,3], 0, [1,2,3], [0,0,0]);
    tl{end+1} = newTest([1    ; 1    ; 1    ], 0, [1],     [0]);
    
    % Test nMinReqSamples
    tl{end+1} = newTest([1,2,3; 1,2,3; 1,2,3], 3, [1,2,3], [0,0,0]);
    tl{end+1} = newTest([1,2,3; 1,2,3; 1,2,3], 4, [nan,nan,nan], [nan,nan,nan]);
    
    
    % Average of two values (special case)
    tl{end+1} = newTest([1,2,3; 2,3,4], 0, [1.5, 2.5, 3.5], sqrt(0.5)*[1,1,1]);
    % Nominal median
    tl{end+1} = newTest([1;2;10],       0, [2], sqrt( (1^2+0^2+8^2)/2 ));
    
    EJ_library.atest.run_tests(tl)
end



function downsample_Epoch___ATEST
    new_test = @(zvAllUtcCa, boundaryRefUtc, intervalLengthWolsNs, timestampPosWolsNs, zvIntervalsUtcCa, iRecordsCa, binSizeArrayNs) ...
        (EJ_library.atest.CompareFuncResult(...
        @bicas.proc_sub23.downsample_Epoch, ...
        {spdfparsett2000(zvAllUtcCa), spdfparsett2000(boundaryRefUtc), int64(intervalLengthWolsNs), int64(timestampPosWolsNs)}, ...
        {spdfparsett2000(zvIntervalsUtcCa), iRecordsCa(:), binSizeArrayNs(:)}));
    ECA = zeros(0,1);
    
    tl = {};
    
    % TEST: No timestamps/empty Epoch.
    tl{end+1} = new_test({}, '2020-01-01T00:00:00', 10e9, 5e9, {}, {}, ECA);
    
    % TEST: One timestamps.
    tl{end+1} = new_test({'2020-01-01T00:00:06'}, '2020-01-01T00:00:00', 10e9, 5e9, {'2020-01-01T00:00:05'}, {1}, [10e9]);
    tl{end+1} = new_test({'2020-01-01T00:00:06'}, '2020-01-01T00:00:01', 10e9, 3e9, {'2020-01-01T00:00:04'}, {1}, [10e9]);
    
    % TEST: Varying number of timestamps in each interval
    tl{end+1} = new_test(...
        {...
        '2020-01-01T00:01:06', ...
        '2020-01-01T00:01:12', ...
        '2020-01-01T00:01:18'
        }, ...
        '2020-01-01T00:00:00', 10e9, 5e9, ...
        {...
        '2020-01-01T00:01:05', ...
        '2020-01-01T00:01:15'...
        }, {1, [2,3]'}, [10e9, 10e9]);
    
    % TEST: Total interval over LEAP SECOND (end of 2016).
    % TEST: Data gap (two intervals without timestamps).
    % TEST: Boundary reference timestamp far from data.
    % TEST: Generally convoluted case...
    % 
    %tl = {};
    tl{end+1} = new_test(...
        {...
        '2016-12-31T23:59:46', ...
        '2016-12-31T23:59:51', ...
        '2016-12-31T23:59:59', ...
        '2017-01-01T00:00:02', ...
        '2017-01-01T00:00:03', ...
        '2017-01-01T00:00:04', ...
        '2017-01-01T00:00:34', ...
        }, ...
        '2020-01-01T00:00:05', 10e9, 5e9, ...
        {...
        '2016-12-31T23:59:50', ...
        '2017-01-01T00:00:00'...
        '2017-01-01T00:00:10', ...
        '2017-01-01T00:00:20'...
        '2017-01-01T00:00:30'...
        }, {[1,2]', [3,4,5,6]', ECA, ECA, [7]}, [10e9, 11e9, 10e9, 10e9, 10e9]);
    
    EJ_library.atest.run_tests(tl);
end
