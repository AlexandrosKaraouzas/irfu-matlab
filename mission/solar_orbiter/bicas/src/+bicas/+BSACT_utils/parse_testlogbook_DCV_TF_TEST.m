function parse_testlogbook_DCV_TF_TEST
%
% Automatic test code for function parse_testlogbook_DCV_TF.
%
%
% Author: Erik P G Johansson, IRF-U, Uppsala, Sweden
% First created 2017-10-12


exp = struct(...
    'antennaSignals',  {}, ...
    'stimuliOhm',      {}, ...
    'testIdNbr',       {}, ...
    'muxMode',         {}, ...
    'outputChNbr',     {}, ...
    'inputChNbr',      {}, ...
    'acGain',          {}, ...
    'invertedInput',   {}, ...
    'commonModeInput', {} ...
    );


rowList = {};
%====================================================================================================
rowList = [rowList, {...
'4-5 AC Transfer Functions', ...
'All transfer functions will be obtained using zero bias, at a minimum of three temperatures and using two types of stimuli, using a network analyser. ', ...
'To see bandwidth behaviour, the measurement range will be extended from 10kHz to 1MHz. ', ...
'Automatic limit checks are made of the whole frequency range, however, in the band of interest, additional limit checks are performed.', ...
'The measurements shall be performed as follows:', ...
'44. Standard test setup shall be used for this test/verification.', ...
'45. Select correct test IDs', ...
'46. If needed run the test file on an EM model to confirm correct EGSE operation.', ...
'47. Load the standard Network settings file test1.sta' ...
}];
%====================================================================================================
rowList = [rowList, {...
'Antenna 2, LFR Output ', ...
'Ant 1 = GND, Ant 2 = Signal, Ant 3 = GND, Stimuli = 100kohm', ...
'ID11 = Mode 0 (std operation), LFR_2 = V12_DC*', ...
'ID12 = Mode 0 (std operation), LFR_3 = V23_DC', ...
'ID13 = Mode 0 (std operation), LFR_4 = V12_AC*, Gain = 5', ...
'ID14 = Mode 0 (std operation), LFR_4 = V12_AC*, Gain = 100', ...
'ID15 = Mode 0 (std operation), LFR_5 = V23_AC, Gain = 5', ...
'ID16 = Mode 0 (std operation), LFR_5 = V23_AC, Gain = 100', ...
'ID17 = Mode 1 (probe 1 fails), LFR_1 = V2_DC', ...
'ID18 = Mode 1 (probe 1 fails), LFR_3 = V23_DC', ...
'ID19 = Mode 3 (probe 3 fails), LFR_2 = V2_DC', ...
'ID20 = Mode 3 (probe 3 fails), LFR_3 = V12_DC*', ...
'ID21 = Mode 4 (cal mode 0), LFR_2 = V2_DC' } ];
exp(end+1) = create_calib_table_record(11, 0, 2, [1 2], NaN, 1, 0);
exp(end+1) = create_calib_table_record(12, 0, 3, [2 3], NaN, 0, 0);
exp(end+1) = create_calib_table_record(13, 0, 4, [1 2], 5,   1, 0);
exp(end+1) = create_calib_table_record(14, 0, 4, [1 2], 100, 1, 0);
exp(end+1) = create_calib_table_record(15, 0, 5, [2 3], 5,   0, 0);
exp(end+1) = create_calib_table_record(16, 0, 5, [2 3], 100, 0, 0);
exp(end+1) = create_calib_table_record(17, 1, 1, [2],   NaN, 0, 0);
exp(end+1) = create_calib_table_record(18, 1, 3, [2 3], NaN, 0, 0);
exp(end+1) = create_calib_table_record(19, 3, 2, [2],   NaN, 0, 0);
exp(end+1) = create_calib_table_record(20, 3, 3, [1 2], NaN, 1, 0);
exp(end+1) = create_calib_table_record(21, 4, 2, [2],   NaN, 0, 0);
exp = set_field(exp, 11, 'antennaSignals', [0 1 0]);
exp = set_field(exp, 11, 'stimuliOhm', 1e5);
%====================================================================================================
rowList = [rowList, {...
'Antenna 1-2 Common Mode, LFR Output', ...
'Ant 1 = Signal, Ant 2 = Signal, Ant 3 = GND, Stimuli = 100kohm', ...
'ID32 = Mode 0 (std operation), LFR_2 = V12_DC*', ...
'ID33 = Mode 0 (std operation), LFR_4 = V12_AC*, Gain = 5', ...
'ID34 = Mode 0 (std operation), LFR_4 = V12_AC*, Gain = 100', ...
'ID35 = Mode 3 (probe 3 fails), LFR_3 = V12_DC*' }];
exp(end+1) = create_calib_table_record(32, 0, 2, [1 2], NaN, 0, 1);
exp(end+1) = create_calib_table_record(33, 0, 4, [1 2], 5,   0, 1);
exp(end+1) = create_calib_table_record(34, 0, 4, [1 2], 100, 0, 1);
exp(end+1) = create_calib_table_record(35, 3, 3, [1 2], NaN, 0, 1);
exp = set_field(exp, 4, 'antennaSignals', [1 1 0]);
exp = set_field(exp, 4, 'stimuliOhm', 1e5);
%====================================================================================================
rowList = [rowList, {...
'Antenna 2-3 Common Mode, LFR Output ', ...
'Ant 1 = GND, Ant 2 = Signal, Ant 3 = Signal, Stimuli = 1Mohm', ...
'ID36 = Mode 0 (std operation), LFR_3 = V23_DC', ...
'ID37 = Mode 0 (std operation), LFR_5 = V23_AC, Gain = 5', ...
'ID38 = Mode 0 (std operation), LFR_5 = V23_AC, Gain = 100', ...
'ID39 = Mode 1 (probe 1 fails), LFR_3 = V23_DC' }];
exp(end+1) = create_calib_table_record(36, 0, 3, [2 3], NaN, 0, 1);
exp(end+1) = create_calib_table_record(37, 0, 5, [2 3], 5,   0, 1);
exp(end+1) = create_calib_table_record(38, 0, 5, [2 3], 100, 0, 1);
exp(end+1) = create_calib_table_record(39, 1, 3, [2 3], NaN, 0, 1);
exp = set_field(exp, 4, 'antennaSignals', [0 1 1]);
exp = set_field(exp, 4, 'stimuliOhm', 1e6);
%====================================================================================================
rowList = [rowList, {...
'TDS Output ', ...
'Ant 1 = Signal, Ant 2 = Signal, Ant 3 = Signal, Stimuli = 100kohm', ...
'ID43 = Mode 4 (cal mode 0), TDS_1 = V1_DC', ...
'ID44 = Mode 4 (cal mode 0), TDS_2 = V2_DC', ...
'ID45 = Mode 4 (cal mode 0), TDS_3 = V3_DC' }];
exp(end+1) = create_calib_table_record(43, 4, 1, [1], NaN, 0, 0);
exp(end+1) = create_calib_table_record(44, 4, 2, [2], NaN, 0, 0);
exp(end+1) = create_calib_table_record(45, 4, 3, [3], NaN, 0, 0);
exp = set_field(exp, 3, 'antennaSignals', [1 1 1]);
exp = set_field(exp, 3, 'stimuliOhm', 1e5);
%====================================================================================================
rowList = [rowList, {...
'For FM tests only:', ...
'If during a test an out of limit is detected the test will be stopped. ', ...
'The test system action is then notified to the test operator and optionally also turns off power and present stimuli. ', ...
'To proceed, proper actions must be taken including analysis, making a decision to terminate or continue the test, and writing a preliminary test report. ', ...
'At the end the decision needs to be signed by the test operator.', ...
'A detailed description of how to perform the test setup is provided by running the file SO_BIAS_Test_Setup.txt.)', ...
'This script will be generated at the first build of the test bench (photos of the test bench are required to generate this script).', ...
'   ', ...
'====================================================================================================================================================', ...
'   ', ...
'Time: 2016-06-22 _09-19-38    ver = C:\Documents and Settings\Administrator\Desktop\SOB_EGSE_EMQ_9_b.vee   OS = Windows_XP    Program started 2016-06-21 _15-20-31   Comment:    Program version information', ...
'    ', ...
'Time: 2016-06-22 _09-19-38    suni = 0   Comment:    DUT ID <BIAS board number>' ...
}];
%====================================================================================================

res = bicas.BSACT_utils.parse_testlogbook_DCV_TF(rowList);

if ~isequaln(exp, res)
    % IMPLEMENTATION NOTE: 
    if numel(exp) ~= numel(res)
        error('Different number of elements')
    end
    for i=1:numel(exp)
        if ~isequaln(exp(i), res(i))
            warning('Elements %i differ', i)
        end
    end
    error('FAIL')
end

end



function Record = create_calib_table_record(testIdNbr, muxMode, outputChNbr, inputChNbr, acGain, invertedInput, commonModeInput)
% Convenience function for assigning components in struct array.
% NOTE: Does not assign all values, only some.
%
% NOTE: Arguments are deliberately in the same order as the quoted testlogbook*.txt printouts.
% PROPOSAL: Make into nested function
% PROPOSAL: Abolish.
% if length(varargin) == 0
%     acGain = NaN;
% elseif length(varargin) == 1
%     acGain = varargin{1};
% else
%     error('BICAS:create_calib_table_record:Assertion', 'Illegal number of arguments.')
% end

Record = struct(...
    'antennaSignals',  [], ...
    'stimuliOhm',      [], ...
    'testIdNbr',       testIdNbr, ...
    'muxMode',         muxMode, ...
    'outputChNbr',     outputChNbr, ...
    'inputChNbr',      inputChNbr, ...
    'acGain',          acGain, ...
    'invertedInput',   invertedInput, ...
    'commonModeInput', commonModeInput);
end



function StructArray = set_field(StructArray, nLastIndices, fieldName, fieldValue)
% Utility function for assigning a specified field in the last N components in a 1D struct array.

for i = numel(StructArray) + [(-nLastIndices+1) : 0]
    StructArray(i).(fieldName) = fieldValue;
end
end
