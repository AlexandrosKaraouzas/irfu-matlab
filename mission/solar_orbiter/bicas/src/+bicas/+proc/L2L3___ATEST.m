%
% Automatic test code.
%
% NOTE: Very low code coverage.
%
function L2L3___ATEST()
    process_L2_to_L3___ATEST
    downsample_sci_zVar___ATEST()
    downsample_Epoch___ATEST
end



% NOTE: Only tests some output values due to the complexity and multitude of
% variables.
%
function process_L2_to_L3___ATEST

    % Conceivable special cases for bins to test, including combinations thereof
    % --------------------------------------------------------------------------
    % No records     (can not be combined with other cases)
    % Only NaN data
    % Partially NaN data
    % QUALITY_FLAG < min value
    % QUALITY_FLAG = fill value
    % #samples < bicas.constants.N_MIN_SAMPLES_PER_DWNS_BIN
    % 
    % NOTE: Makes no sense testing the actual output data, since it is dependent
    % on BICAS-external functions, except maybe whether it is NaN or not.
    
    % Test(s) are designed for this value.
    assert(bicas.constants.N_MIN_SAMPLES_PER_DWNS_BIN == 3)
    
    
    
    N = NaN;
    L        = bicas.logger('none', 0);
    SETTINGS = bicas.create_default_SETTINGS();
    SETTINGS.make_read_only();



    InLfrCwf.ZvFv = struct(...
        'QUALITY_FLAG',       uint8(255), ...
        'QUALITY_BITMASK',    uint16(65535), ...
        'L2_QUALITY_BITMASK', uint16(65535));
    InLfrCwf.Ga.OBS_ID    = {' '};
    InLfrCwf.Ga.SOOP_TYPE = {' '};
    
    %============================================================================
    % ORIS DATA: Input+expected output
    % --------------------------------
    % Defines bins representing different special cases.
    %
    % NOTE: No consistent relationship between VDC and EDC values, since that is
    % not needed for testing.
    %============================================================================
    % Columns: Epoch [s], QUALITY_FLAG_in, QUALITY_FLAG_ORIS_out, ...
    DATA1 = [...
        % Normal bin
        % Test merging QUALITY_BITMASK bits.
         -1,   2,   2, 1,  8,   1,2,3, -1,-2,-3; ...
          0,   2,   2, 2, 16,   1,2,3, -1,-2,-3; ...
          1,   2,   2, 4, 32,   1,2,3, -1,-2,-3; ...
        % Too few records
         10,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
        % Zero records
        % - (no data)
        % One QUALITY_FLAG too low, but still enough records.
         30,   1, 255, 0,  0,   1,2,3, -1,-2,-3; ...
         31,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
         32,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
         33,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
        % One QUALITY_FLAG too low, and therefore NOT enough records.
         40,   1, 255, 0,  0,   1,2,3, -1,-2,-3; ...
         41,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
         42,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
        % All QUALITY_FLAG too low.
         50,   1, 255, 0,  0,   1,2,3, -1,-2,-3; ...
         51,   1, 255, 0,  0,   1,2,3, -1,-2,-3; ...
         52,   1, 255, 0,  0,   1,2,3, -1,-2,-3; ...
         % One QUALITY_FLAG==fill value, but still enough records.
         60, 255, 255, 0,  0,   1,2,3, -1,-2,-3; ...
         61,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
         62,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
         63,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
         % One QUALITY_FLAG==fill value, NOT enough other records, enough DATA.
         % ==> Ambiguous.
         % Should never have input QUALITY_FLAG==fill value + non-NaN data in
         % the first place.
         70, 255, 255, 0,  0,   1,2,3, -1,-2,-3; ...
         71,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
         72,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
         % All QUALITY_FLAG==fill value
         80, 255, 255, 0,  0,   1,2,3, -1,-2,-3; ...
         81, 255, 255, 0,  0,   1,2,3, -1,-2,-3; ...
         82, 255, 255, 0,  0,   1,2,3, -1,-2,-3; ...
        % All data NaN
         90,   2, 255, 0,  0,   N,N,N, N,N,N; ...
         91,   2, 255, 0,  0,   N,N,N, N,N,N; ...
         92,   2, 255, 0,  0,   N,N,N, N,N,N; ...
        % Some data NaN, ==> Not enough records/data
        100,   2, 255, 0,  0,   N,N,N, N,N,N; ...
        101,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
        102,   2,   2, 0,  0,   1,2,3, -1,-2,-3; ...
        ];
    
    %===========
    % DWNS DATA
    %===========
    DATA2 = [...
          0,   2,     7,    56; ...
         10, 255,     0,     0; ...
         20, 255, 65535, 65535; ...
         30,   2,     0,     0; ...
         40, 255,     0,     0; ...
         50, 255,     0,     0; ...
         60,   2,     0,     0; ...
         70,   2,     0,     0; ...
         80, 255,     0,     0; ...
         90, 255,     0,     0; ...
        100, 255,     0,     0; ...
        ];
    
    BASE_TT2000 = spdfparsett2000('2020-03-14T00:00:00');

    InLfrCwf.Zv.Epoch              = int64( DATA1(:, 1)*1e9) + BASE_TT2000;
    InLfrCwf.Zv.QUALITY_FLAG       = uint8( DATA1(:, 2));
    InLfrCwf.Zv.QUALITY_BITMASK    = uint16(DATA1(:, 4));
    InLfrCwf.Zv.L2_QUALITY_BITMASK = uint16(DATA1(:, 5));
    InLfrCwf.Zv.DELTA_PLUS_MINUS   = int64(ones(size(InLfrCwf.Zv.Epoch))) * mode(diff(InLfrCwf.Zv.Epoch));
    InLfrCwf.Zv.VDC = single(DATA1(:, 6: 8));
    InLfrCwf.Zv.EDC = single(DATA1(:, 9:11));

    ExpOris.Zv.QUALITY_FLAG       = uint8( DATA1(:, 3));
    %
    ExpDwns.Zv.Epoch              = int64( DATA2(:, 1)*1e9) + BASE_TT2000;
    ExpDwns.Zv.QUALITY_FLAG       = uint8( DATA2(:, 2));
    ExpDwns.Zv.QUALITY_BITMASK    = uint16(DATA2(:, 3));
    ExpDwns.Zv.L2_QUALITY_BITMASK = uint16(DATA2(:, 4));
    
    [OutEfieldOris,  OutEfieldDwns, ...
     OutScpotOris,   OutScpotDwns, ...
     OutDensityOris, OutDensityDwns] ...
    = bicas.proc.L2L3.process_L2_to_L3(InLfrCwf, SETTINGS, L);

    % ORIS
    assert(all(OutEfieldOris.Zv.Epoch              == InLfrCwf.Zv.Epoch))
    assert(all(OutEfieldOris.Zv.QUALITY_FLAG       == ExpOris.Zv.QUALITY_FLAG))
    assert(all(OutEfieldOris.Zv.QUALITY_BITMASK    == InLfrCwf.Zv.QUALITY_BITMASK))
    assert(all(OutEfieldOris.Zv.L2_QUALITY_BITMASK == InLfrCwf.Zv.L2_QUALITY_BITMASK))
    
    % DWNS
    assert(all(OutEfieldDwns.Zv.Epoch              == ExpDwns.Zv.Epoch))
    assert(all(OutEfieldDwns.Zv.QUALITY_FLAG       == ExpDwns.Zv.QUALITY_FLAG))
    assert(all(OutEfieldDwns.Zv.QUALITY_BITMASK    == ExpDwns.Zv.QUALITY_BITMASK), 'QUALITY_BITMASK')
    assert(all(OutEfieldDwns.Zv.L2_QUALITY_BITMASK == ExpDwns.Zv.L2_QUALITY_BITMASK))
end



% Internal utility function
function assert_iRecordsDwnsCa(iRecordsDwnsCa, zv)
    
    % ~Normalize
    iRecordsDwnsNormCa = arrayfun(...
        @(s) (s{1}(:)'), ...
        iRecordsDwnsCa, ...
        'UniformOutput', false);
    
    iRecordsArray = [iRecordsDwnsNormCa{:}];
    
    assert(all(unique(iRecordsArray) == 1:size(zv, 1)))
end



function downsample_sci_zVar___ATEST
    
    tl = {};

    % function [zvMed, zvMstd, bTooFewRecords] = downsample_sci_zVar(...
    %                 zv, nMinReqRecords, iRecordsInBinCa)
    
    % Create test with exactly ONE BIN.
    function add_test_1_bin(zv, nMinReqSamples, med, mstd)
        tl{end+1} = EJ_library.atest.CompareFuncResult(...
            @bicas.proc.L2L3.downsample_sci_zVar, ...
            {zv, nMinReqSamples, {1:size(zv,1)}}, ...
            {med, mstd});
    end

	% Create test with N BINS (i.e. an arbitrary call).
    function add_test_N_bin(zv, nMinReqSamples, iRecordsDwnsCa, med, mstd)
        assert(isrow(iRecordsDwnsCa))
        assert_iRecordsDwnsCa(iRecordsDwnsCa, zv)
        
        tl{end+1} = EJ_library.atest.CompareFuncResult(...
            @bicas.proc.L2L3.downsample_sci_zVar, ...
            {zv, nMinReqSamples, iRecordsDwnsCa'}, ...
            {med, mstd});
    end

    
    AS10 = zeros(1,0);   % AS10 = Array Size 1x0
    N = NaN;


    % Empty data, zero records, zero columns.
    add_test_1_bin(zeros(0,0), 0, AS10, AS10);
    add_test_1_bin(zeros(2,0), 0, AS10, AS10);
    add_test_1_bin(zeros(0,2), 0, NaN(1,2), NaN(1,2));
    
    % mstd=0
    add_test_1_bin([1,2,3              ], 0, [1,2,3], [nan,nan,nan]);
    add_test_1_bin([1,2,3; 1,2,3       ], 0, [1,2,3], [0,0,0]);
    add_test_1_bin([1,2,3; 1,2,3; 1,2,3], 0, [1,2,3], [0,0,0]);
    add_test_1_bin([1    ; 1    ; 1    ], 0, [1],     [0]);
    
    % Test nMinReqSamples
    % -------------------
    % Enough samples
    add_test_1_bin([1,2,3; 1,2,3; 1,2,3], 3, [1,2,3], [0,0,0]);
    % Not enough samples
    add_test_1_bin([1,2,3; 1,2,3; 1,2,3], 4, [N,N,N], [N,N,N]);
    % Not enough samples if removes NaN.
    add_test_1_bin([1,2,3; 1,2,3; 1,2,N],        3, [1,2,N], [0,0,N]);
    % Enough samples even if removes NaN.
    add_test_1_bin([1,2,3; 1,2,3; 1,2,N; 1,2,3], 3, [1,2,3], [0,0,0]);

    
    
    % Average of two values (special case)
    add_test_1_bin([1,2,3; 2,3,4], 0, [1.5, 2.5, 3.5], sqrt(0.5)*[1,1,1]);
    % Nominal median
    add_test_1_bin([1;2;10],       0, [2], sqrt( (1^2+0^2+8^2)/2 ));

    
    
    add_test_N_bin([1,2; 2,3], 1, {1, 2}, [1,2; 2,3], NaN(2,2))
    
    add_test_N_bin(...
        [1, 2; ...
         2, 3; ...
         3, 4; ...
         4, 5; ...
         5, 6], 1, {1:2, 3:5}, ...
        [1.5, 2.5; ...
         4,   5   ], ...
        [sqrt(2*0.5^2)/1 * [1,1]; ...
         sqrt(4*1^2  )/2 * [1,1]])
     
    add_test_N_bin(...
        [1, 2; ...
         2, 3; ...
         3, 4; ...
         4, 5; ...
         5, 6], 1, {1:2, [], 3:5}, ...
        [1.5, 2.5; ...
         NaN, NaN; ...
         4,   5], ...
        [sqrt(2*0.5^2)/1 * [1,1]; ...
         NaN, NaN; 
         sqrt(4*1^2  )/2 * [1,1]])
     
    % Higher threshold
    add_test_N_bin([1,2; 2,3; 3,4; 4,5; 5,6], 3, {1:2, [], 3:5}, ...
        [NaN, NaN; ...
         NaN, NaN; ...
         4, 5], ...
        [NaN, NaN; ...
         NaN, NaN; 
         sqrt(4*1^2  )/2 * [1,1]])

    
    
    EJ_library.atest.run_tests(tl)
end



function downsample_Epoch___ATEST
    
    function add_test(...
            zvAllUtcCa, ...
            boundaryRefUtc, ...
            intervalLengthWolsNs, ...
            timestampPosWolsNs, ...
            ...
            zvIntervalsUtcCa, ...
            iRecordsCa, ...
            nRecordsPerBin, ...
            binSizeArrayNs)

        tl{end+1} = EJ_library.atest.CompareFuncResult(...
            @bicas.proc.L2L3.downsample_Epoch, ...
            ...
            {spdfparsett2000(zvAllUtcCa), ...
            spdfparsett2000(boundaryRefUtc), ...
            int64(intervalLengthWolsNs), ...
            int64(timestampPosWolsNs)}, ...
            ...
            {spdfparsett2000(zvIntervalsUtcCa), ...
            iRecordsCa(:), ...
            nRecordsPerBin(:), ...
            binSizeArrayNs(:)});
    end
    
    
    % ECA = Empty Column (size=0) Array
    ECA = zeros(0,1);
    
    tl = {};
    
    % TEST: No timestamps/empty Epoch.
    add_test({}, '2020-01-01T00:00:00', 10e9, 5e9, {}, {}, [], ECA);
    
    % TEST: One timestamps.
    add_test({'2020-01-01T00:00:06'}, '2020-01-01T00:00:00', 10e9, 5e9, {'2020-01-01T00:00:05'}, {1}, [1], [10e9]);
    add_test({'2020-01-01T00:00:06'}, '2020-01-01T00:00:01', 10e9, 3e9, {'2020-01-01T00:00:04'}, {1}, [1], [10e9]);
    
    % TEST: Varying number of timestamps in each interval
    add_test(...
        {...
        '2020-01-01T00:01:06', ...
        '2020-01-01T00:01:12', ...
        '2020-01-01T00:01:18'
        }, ...
        '2020-01-01T00:00:00', 10e9, 5e9, ...
        {...
        '2020-01-01T00:01:05', ...
        '2020-01-01T00:01:15'...
        }, {1, [2,3]'}, [1,2], [10e9, 10e9]);
    
    % TEST: Total interval over LEAP SECOND (end of 2016).
    % TEST: Data gap (two intervals without timestamps).
    % TEST: Boundary reference timestamp far from data.
    % TEST: Generally convoluted case...
    % 
    %tl = {};
    add_test(...
        {...
        '2016-12-31T23:59:46', ...
        '2016-12-31T23:59:51', ...
        '2016-12-31T23:59:59', ...
        '2017-01-01T00:00:02', ...
        '2017-01-01T00:00:03', ...
        '2017-01-01T00:00:04', ...
        '2017-01-01T00:00:34', ...
        }, ...
        '2020-01-01T00:00:05', 10e9, 5e9, ...
        {...
        '2016-12-31T23:59:50', ...
        '2017-01-01T00:00:00'...
        '2017-01-01T00:00:10', ...
        '2017-01-01T00:00:20'...
        '2017-01-01T00:00:30'...
        }, {[1,2]', [3,4,5,6]', ECA, ECA, [7]}, [2,4,0,0,1], [10e9, 11e9, 10e9, 10e9, 10e9]);
    
    EJ_library.atest.run_tests(tl);
end
